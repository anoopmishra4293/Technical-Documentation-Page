<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Technical Documentation</title>
</head>

<body>
    <style>
        code {
            font-size: 14px;
        }

        #navbar {
            position: fixed;
            left: 0%;
            width: 240px;
            height: 100%;
            border-style: solid;
            padding: 2%;
            background-color: rgb(243, 240, 240);
        }

        .nav-link {
            margin-bottom: 100px;
        }

        .container {
            padding-left: 360px;
            padding-right: 10%;
        }

        p {
            font-size: 19px;
        }

        .sec-head {
            font-size: 30px;
            color: brown;
        }

        h1 {
            color: brown;
        }

        h3 {
            font-size: 25px;
            color: crimson;
        }

        li {
            font-size: 21px;
            color: firebrick;
        }

        @media screen and (max-width: 800px) {
            #navbar {
                width: 220px;
            }

            .container {
                padding-left: 300px;
            }
        }
    </style>
    <nav id="navbar"></strong>
        <header id="nav-header"><strong> csv — CSV File Reading and Writing</header><br>
        <li><a class="nav-link" href="#Module_Contents">Module Contents</a></li><br>
        <li><a class="nav-link" href="#Dialects_and_Formatting_Parameters">Dialects and Formatting Parameters</a></li>
        <br>
        <li><a class="nav-link" href="#Reader_Objects">Reader Objects</a></li><br>
        <li><a class="nav-link" href="#Writer_Objects">Writer Objects</a></li><br>
        <li><a class="nav-link" href="#Examples">Examples</a></li><br>
    </nav>

    <div class="container">
        <h1>csv — CSV File Reading and Writing</h1>

        <p>The so-called CSV (Comma Separated Values) format is the most common import and export format for
            spreadsheets and databases. CSV format was used for many years prior to attempts to describe the format in a
            standardized way in RFC 4180. The lack of a well-defined standard means that subtle differences often exist
            in the data produced and consumed by different applications. These differences can make it annoying to
            process CSV files from multiple sources. Still, while the delimiters and quoting characters vary, the
            overall format is similar enough that it is possible to write a single module which can efficiently
            manipulate such data, hiding the details of reading and writing the data from the programmer.</p>
        <p>The <code>csv</code> module implements classes to read and write tabular data in CSV format. It allows
            programmers to say, “write this data in the format preferred by Excel,” or “read data from this file which
            was generated by Excel,” without knowing the precise details of the CSV format used by Excel. Programmers
            can also describe the CSV formats understood by other applications or define their own special-purpose CSV
            formats.</p>
        <p>The <code>csv</code> module’s <code>reader</code> and <code>writer</code> objects read and write sequences.
            Programmers can also read and write data in dictionary form using the DictReader and DictWriter classes.</p>

        <main id="main-doc">

            <section class="main-section" id="Module_Contents">
                <header class="sec-head">Module Contents</header> <br>

                <li>The csv module defines the following functions:</li>

                <h3>csv.reader(csvfile, dialect='excel', **fmtparams)</h3>
                <p> Return a reader object which will iterate over lines in the given csvfile. csvfile can be any object
                    which supports the iterator protocol and returns a string each time its __next__() method is called
                    — file objects and list objects are both suitable. If csvfile is a file object, it should be opened
                    with newline=''.An optional dialect parameter can be given which is used to define a set of
                    parameters specific to a particular CSV dialect. It may be an instance of a subclass of the
                    Dialectclass or one of the strings returned by the list_dialects() function. The other optional
                    fmtparams keyword arguments can be given to override individual formatting parameters in the current
                    dialect. For full details about the dialect and formatting parameters, see section Dialects and
                    Formatting Parameters. <br>
                    Each row read from the csv file is returned as a list of strings. No automatic data type conversion
                    is performed unless the QUOTE_NONNUMERIC format option is specified (in which case unquoted fields
                    are transformed into floats).</p>

                <li>A short usage example:</li>

                <code>
                    >>><br>
                    >>> import csv <br>
                    >>> with open('eggs.csv', newline='') as csvfile:<br>
                    ...     spamreader = csv.reader(csvfile, delimiter=' ', quotechar='|') <br>
                    ...     for row in spamreader: <br>
                    ...         print(', '.join(row)) <br>
                    Spam, Spam, Spam, Spam, Spam, Baked Beans <br>
                    Spam, Lovely Spam, Wonderful Spam
                </code> <br>

                <h3>csv.writer(csvfile, dialect='excel', **fmtparams)</h3>
                <p> Return a writer object responsible for converting the user’s data into delimited strings on the
                    given file-like object. csvfile can be any object with a write() method. If csvfile is a file
                    object, it should be opened with newline=''. An optional dialect parameter can be given which is
                    used to define a set of parameters specific to a particular CSV dialect. It may be an instance of a
                    subclass of the Dialect class or one of the strings returned by the list_dialects() function. The
                    other optional fmtparams keyword arguments can be given to override individual formatting parameters
                    in the current dialect. For full details about the dialect and formatting parameters, see section
                    Dialects and Formatting Parameters. To make it as easy as possible to interface with modules which
                    implement the DB API, the value None is written as the empty string. While this isn’t a reversible
                    transformation, it makes it easier to dump SQL NULL data values to CSV files without preprocessing
                    the data returned from a cursor.fetch* call. All other non-string data are stringified with str()
                    before being written. </p>

                <li>A short usage example:</li>
                <code>
                    import csv <br>
                    with open('eggs.csv', 'w', newline='') as csvfile: <br>
                        spamwriter = csv.writer(csvfile, delimiter=' ',
                                                quotechar='|', quoting=csv.QUOTE_MINIMAL) <br>
                        spamwriter.writerow(['Spam'] * 5 + ['Baked Beans']) <br>
                        spamwriter.writerow(['Spam', 'Lovely Spam', 'Wonderful Spam']) <br>
                </code><br>
                <h3>csv.register_dialect(name[, dialect[, **fmtparams]])</h3>
                <p>Associate dialect with name. name must be a string. The dialect can be specified either by passing a
                    sub-class of Dialect, or by fmtparams keyword arguments, or both, with keyword arguments overriding
                    parameters of the dialect. For full details about the dialect and formatting parameters, see section
                    Dialects and Formatting Parameters.</p>

                <h3>csv.unregister_dialect(name)</h3>
                <p> Delete the dialect associated with name from the dialect registry. An Error is raised if name is not
                    a registered dialect name.</p>

                <h3>csv.get_dialect(name)</h3>
                <p> Return the dialect associated with name. An Error is raised if name is not a registered dialect
                    name. This function returns an immutable Dialect.</p>

                <h3>csv.list_dialects()</h3>
                <p> Return the names of all registered dialects.</p>

                <h3>csv.field_size_limit([new_limit])</h3>
                <p> Returns the current maximum field size allowed by the parser. If new_limit is given, this becomes
                    the new limit.</p>
            </section>

            <section class="main-section" id="Dialects_and_Formatting_Parameters">
                <header class="sec-head">Dialects and Formatting Parameters</header>
                <p>To make it easier to specify the format of input and output records, specific formatting parameters
                    are grouped together into dialects. A dialect is a subclass of the Dialect class having a set of
                    specific methods and a single validate() method. When creating reader or writer objects, the
                    programmer can specify a string or a subclass of the Dialect class as the dialect parameter. In
                    addition to, or instead of, the dialect parameter, the programmer can also specify individual
                    formatting parameters, which have the same names as the attributes defined below for the Dialect
                    class.</p>

                <p> Dialects support the following attributes:</p>

                <h3>Dialect.delimiter</h3>
                <p> A one-character string used to separate fields. It defaults to ','.</p>

                <h3>Dialect.doublequote</h3>
                <p>Controls how instances of quotechar appearing inside a field should themselves be quoted. When True,
                    the character is doubled. When False, the escapechar is used as a prefix to the quotechar. It
                    defaults to True. <br>
                    On output, if doublequote is False and no escapechar is set, Error is raised if a quotechar is found
                    in a field.</p>

                <h3>Dialect.escapechar</h3>
                <p> A one-character string used by the writer to escape the delimiter if quoting is set to QUOTE_NONE
                    and the quotechar if doublequote is False. On reading, the escapechar removes any special meaning
                    from the following character. It defaults to None, which disables escaping.</p>

                <h3>Dialect.lineterminator</h3>
                <p> The string used to terminate lines produced by the writer. It defaults to '\r\n'.</p>

                <p> Note The reader is hard-coded to recognise either '\r' or '\n' as end-of-line, and ignores
                    lineterminator. This behavior may change in the future.</p>
                <h3>Dialect.quotechar</h3>
                <p> A one-character string used to quote fields containing special characters, such as the delimiter or
                    quotechar, or which contain new-line characters. It defaults to '"'.</p>

                <h3>Dialect.quoting</h3>
                <p> Controls when quotes should be generated by the writer and recognised by the reader. It can take on
                    any of the QUOTE_* constants (see section Module Contents) and defaults to QUOTE_MINIMAL.</p>

                <h3>Dialect.skipinitialspace</h3>
                <p> When True, whitespace immediately following the delimiter is ignored. The default is False.</p>

                <h3>Dialect.strict</h3>
                <p>When True, raise exception Error on bad CSV input. The default is False.</p>
            </section>

            <section class="main-section" id="Reader_Objects">
                <header class="sec-head">Reader Objects</header>
                <li>Reader objects have the following public methods:</li>

                <h3>csvreader.__next__()</h3>
                <p> Return the next row of the reader’s iterable object as a list (if the object was returned from
                    reader()) or a dict (if it is a DictReader instance), parsed according to the current dialect.
                    Usually you should call this as next(reader).</p>

                <li>Reader objects have the following public attributes:</li>

                <h3>csvreader.dialect</h3>
                A read-only description of the dialect in use by the parser.

                <h3>csvreader.line_num</h3>
                <p>The number of lines read from the source iterator. This is not the same as the number of records
                    returned, as records can span multiple lines.</p>

                <li>DictReader objects have the following public attribute:</li>

                <h3>csvreader.fieldnames</h3>
                <p>If not passed as a parameter when creating the object, this attribute is initialized upon first
                    access or when the first record is read from the file.</p>
            </section>

            <section class="main-section" id="Writer_Objects">
                <header class="sec-head">Writer Objects</header>
                <p>Writer objects (DictWriter instances and objects returned by the writer() function) have the
                    following public methods. A row must be an iterable of strings or numbers for Writer objects and a
                    dictionary mapping fieldnames to strings or numbers (by passing them through str() first) for
                    DictWriter objects. Note that complex numbers are written out surrounded by parens. This may cause
                    some problems for other programs which read CSV files (assuming they support complex numbers at
                    all).</p>

                <h3>csvwriter.writerow(row)</h3>
                <p> Write the row parameter to the writer’s file object, formatted according to the current dialect.
                    Return the return value of the call to the write method of the underlying file object.</p>

                <li>Changed in version 3.5: Added support of arbitrary iterables.</li>

                <h3>csvwriter.writerows(rows)</h3>
                <p>Write all elements in rows (an iterable of row objects as described above) to the writer’s file
                    object, formatted according to the current dialect.</p>

                <li>Writer objects have the following public attribute:</li>

                <h3>csvwriter.dialect</h3>
                <p> A read-only description of the dialect in use by the writer.</p>
                <li>DictWriter objects have the following public method:</li>

                <h3>DictWriter.writeheader()</h3>
                <p>Write a row with the field names (as specified in the constructor) to the writer’s file object,
                    formatted according to the current dialect. Return the return value of the csvwriter.writerow() call
                    used internally.</p>

                <li>Changed in version 3.8:</li>

                <p>writeheader() now also returns the value returned by the csvwriter.writerow() method it uses
                    internally.</p>
            </section>

            <section class="main-section" id="Examples">
                <header class="sec-head">Examples</header> <br>
                <li>The simplest example of reading a CSV file:</li>
                <code>
                    import csv <br>
                    with open('some.csv', newline='') as f: <br>
                        reader = csv.reader(f) <br>
                        for row in reader: <br>
                            print(row) <br>
                </code> <br>
                <li>Reading a file with an alternate format:</li>
                <code>
                    import csv <br>
                    with open('passwd', newline='') as f: <br>
                        reader = csv.reader(f, delimiter=':', quoting=csv.QUOTE_NONE) <br>
                        for row in reader: <br>
                            print(row) <br>
                </code> <br>
                <li>The corresponding simplest possible writing example is:</li>
                <code>
                    import csv <br>
                    with open('some.csv', 'w', newline='') as f: <br>
                        writer = csv.writer(f) <br>
                        writer.writerows(someiterable) <br>
                </code>

                <p>Since open() is used to open a CSV file for reading, the file will by default be decoded into unicode
                    using the system default encoding (see locale.getpreferredencoding()). </p>
                <li> To decode a file using a different encoding, use the encoding argument of open:</li>
                <code>
                    import csv <br>
                    with open('some.csv', newline='', encoding='utf-8') as f: <br>
                        reader = csv.reader(f) <br>
                        for row in reader: <br>
                            print(row) <br>
                    </code>

                <p> The same applies to writing in something other than the system default encoding: specify the
                    encoding argument when opening the output file.</p>

                <li> Registering a new dialect:</li>
                <code>
                    import csv <br>
                    csv.register_dialect('unixpwd', delimiter=':', quoting=csv.QUOTE_NONE) <br>
                    with open('passwd', newline='') as f: <br>
                        reader = csv.reader(f, 'unixpwd') <br>
                </code> <br>
                <li> A slightly more advanced use of the reader — catching and reporting errors:</li>
                <code>
                    import csv, sys <br>
                    filename = 'some.csv' <br>
                    with open(filename, newline='') as f: <br>
                        reader = csv.reader(f) <br>
                        try: <br>
                            for row in reader: <br>
                                print(row) <br>
                        except csv.Error as e: <br>
                            sys.exit('file {}, line {}: {}'.format(filename, reader.line_num, e)) <br>
                </code> <br>
                <li> And while the module doesn’t directly support parsing strings, it can easily be done:</li>
                <code>
                    import csv <br>
                    for row in csv.reader(['one,two,three']): <br>
                        print(row) <br>
                    </code> <br>
                <h3>Footnotes</h3>

                <p> If newline='' is not specified, newlines embedded inside quoted fields will not be interpreted
                    correctly, and on platforms that use \r\n linendings on write an extra \r will be added. It should
                    always be safe to specify newline='', since the csv module does its own (universal) newline
                    handling.</p>
            </section>

        </main>
    </div>

</body>

</html>